const multer = require('multer');
const csv = require('csv-parser');
const xlsx = require('xlsx');
const fs = require('fs');
const path = require('path');
require('dotenv').config();
console.log('JWT_SECRET cargado en el servidor:', process.env.JWT_SECRET);

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const http = require('http');
const { Server } = require('socket.io');
const pool = require('./db');
const logger = require('./logger');
const suppliersRoutes = require('./routes/suppliers');
const salesRouter = require('./routes/sales');
const jwt = require('jsonwebtoken');

const app = express();
const server = http.createServer(app);
const allowedOrigins = [
    'http://localhost:3000',
    'http://127.0.0.1:3000',
    'http://localhost:8080',
    'http://127.0.0.1:8080',
    'http://localhost:5817',
    'http://127.0.0.1:5817',
    process.env.FRONTEND_URL
].filter(Boolean);

const io = new Server(server, {
    cors: {
        origin: allowedOrigins,
        methods: ['GET', 'POST', 'PUT', 'DELETE'],
        allowedHeaders: ['Content-Type', 'Authorization', 'x-auth-token']
    }
});

logger.info('Socket.IO inicializado, cliente disponible en /socket.io/socket.io.js');

// Configuración de proveedores
const PROVEEDORES = {
    'PS-00001': { nombre: 'Sanchez Import', carpeta: 'Sanchez Import', imagenes: 'Fotos Sanchez Import' },
    'MAS-i002': { nombre: 'Mastro', carpeta: 'Mastro', imagenes: 'Fotos_Mastro' },
    'ARG-C003': { nombre: 'ARG Import', carpeta: 'ARG_importaciones', imagenes: 'Fotos_ARG' },
    'Mcc-i004': { nombre: 'MultiOcc', carpeta: 'MultiOcc', imagenes: 'Fotos_MultiOcc' },
    'Wic-A1': { nombre: 'WillCars Import', carpeta: 'WillCars Import', imagenes: 'Fotos_WillCars' },
    'kod-Sc001': { nombre: 'Kode Import', carpeta: 'Kode import', imagenes: 'Fotos_Kode' }
};

const BASE_UPLOADS = path.join(__dirname, 'Uploads');
const DEFAULT_IMAGE = '/Uploads/default.jpg';

// Configurar multer para manejar subidas de archivos
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        const uploadPath = req.path === '/api/upload-provider-csv' ? path.join(BASE_UPLOADS, 'temp') : BASE_UPLOADS;
        cb(null, uploadPath);
    },
    filename: (req, file, cb) => {
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
        cb(null, `${file.fieldname}-${uniqueSuffix}${path.extname(file.originalname)}`);
    }
});

const upload = multer({
    storage: storage,
    fileFilter: (req, file, cb) => {
        if (file.mimetype === 'text/csv' || file.mimetype.startsWith('image/') || file.mimetype === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') {
            cb(null, true);
        } else {
            cb(new Error('Solo se permiten archivos CSV, Excel o imágenes'), false);
        }
    },
    limits: { fileSize: 5 * 1024 * 1024 } // Límite de 5MB
});

// Probar conexión a la base de datos
pool.connect((err) => {
    if (err) {
        logger.error('Error conectando a la base de datos:', err);
        process.exit(1);
    }
    logger.info('Conexión a la base de datos exitosa');
});

// Middlewares
app.use(cors({
    origin: allowedOrigins,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'x-auth-token'],
    credentials: true
}));

app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            scriptSrc: [
                "'self'",
                'https://code.jquery.com',
                'https://cdn.jsdelivr.net',
                'http://localhost:3000',
                'http://localhost:8080',
                'http://localhost:5817',
                'https://cdnjs.cloudflare.com',
                'https://stackpath.bootstrapcdn.com',
                'https://cdn.socket.io',
                'https://ajax.googleapis.com',
                "'unsafe-inline'"
            ],
            scriptSrcAttr: ["'unsafe-inline'"],
            styleSrc: [
                "'self'",
                'https://cdn.jsdelivr.net',
                'https://cdnjs.cloudflare.com',
                'https://stackpath.bootstrapcdn.com',
                'https://fonts.googleapis.com',
                "'unsafe-inline'"
            ],
            fontSrc: [
                "'self'",
                'https://cdnjs.cloudflare.com',
                'https://fonts.gstatic.com'
            ],
            imgSrc: [
                "'self'",
                'http://localhost:3000',
                'http://localhost:3000/Uploads/*',
                'http://localhost:8080',
                'http://localhost:5817',
                'data:'
            ],
            connectSrc: [
                "'self'",
                'http://localhost:3000',
                'ws://localhost:3000',
                'wss://localhost:3000',
                'http://localhost:8080',
                'ws://localhost:8080',
                'http://localhost:5817',
                'ws://localhost:5817'
            ],
            formAction: ["'self'"],
            objectSrc: ["'none'"],
            mediaSrc: ["'none'"],
            frameSrc: ["'none'"]
        }
    }
}));

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Middleware para manejar errores de Multer
const handleMulterError = (err, req, res, next) => {
    if (err instanceof multer.MulterError) {
        logger.error(`Error de Multer: ${err.message}, campo: ${err.field}`);
        return res.status(400).json({ error: `Error al procesar el archivo: ${err.message}` });
    }
    logger.error(`Error no Multer: ${err.message}`);
    next(err);
};

// Servir archivos estáticos
app.use(express.static(path.join(__dirname, '../frontend')));
app.use('/supplier_logos', express.static(path.join(__dirname, '..', 'frontend', 'img', 'ico')));
app.use('/Uploads', cors({
    origin: allowedOrigins,
    methods: ['GET'],
    allowedHeaders: ['Content-Type']
}), (req, res, next) => {
    req.url = decodeURI(req.url);
    next();
}, express.static(BASE_UPLOADS));

// Verificar token
function verifyToken(token) {
    try {
        return jwt.verify(token, process.env.JWT_SECRET);
    } catch (error) {
        throw new Error('Token inválido');
    }
}

// Subir CSV/Excel por proveedor
app.post('/api/upload-provider-csv', upload.single('file'), handleMulterError, async (req, res) => {
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) return res.status(401).json({ message: 'No autorizado' });

    try {
        const user = verifyToken(token);
        if (user.role !== 'proveedor') return res.status(403).json({ message: 'Solo proveedores' });

        const filePath = req.file.path;
        const proveedorId = user.proveedor_id;
        const proveedor = PROVEEDORES[proveedorId];
        if (!proveedor) return res.status(400).json({ message: 'Proveedor no válido' });

        const tempPath = path.join(BASE_UPLOADS, 'temp', `${proveedorId}_${Date.now()}_${req.file.originalname}`);

        // Convertir Excel a CSV si es necesario
        if (req.file.originalname.endsWith('.xlsx')) {
            const workbook = xlsx.readFile(filePath);
            const sheet = workbook.Sheets[workbook.SheetNames[0]];
            const csvData = xlsx.utils.sheet_to_csv(sheet);
            fs.writeFileSync(tempPath, csvData);
            fs.unlinkSync(filePath);
        } else {
            fs.renameSync(filePath, tempPath);
        }

        // Guardar en la base de datos
        await pool.query(
            'INSERT INTO pending_csvs (proveedor_id, file_path, status, created_at) VALUES ($1, $2, $3, $4)',
            [proveedorId, tempPath, 'pending', new Date()]
        );
        res.json({ message: 'Archivo subido, pendiente de aprobación' });
    } catch (error) {
        logger.error(`Error al procesar subida: ${error.message}`);
        res.status(500).json({ message: 'Error al procesar el archivo' });
    }
});

// Listar CSVs pendientes
app.get('/api/pending-csvs', async (req, res) => {
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) return res.status(401).json({ message: 'No autorizado' });

    try {
        const user = verifyToken(token);
        if (user.role !== 'admin') return res.status(403).json({ message: 'Solo administradores' });

        const { rows } = await pool.query('SELECT * FROM pending_csvs WHERE status = $1', ['pending']);
        res.json({ csvs: rows });
    } catch (error) {
        logger.error(`Error al listar CSVs pendientes: ${error.message}`);
        res.status(500).json({ message: 'Error al listar CSVs' });
    }
});

// Previsualizar CSV
app.post('/api/preview-csv', async (req, res) => {
    const { filePath, proveedorId } = req.body;
    const proveedor = PROVEEDORES[proveedorId];
    if (!proveedor) return res.status(400).json({ message: 'Proveedor no válido' });

    const imageBasePath = `/Uploads/${proveedor.carpeta}/${proveedor.imagenes}/`;
    const imageDir = path.join(BASE_UPLOADS, proveedor.carpeta, proveedor.imagenes);
    const mappingCsv = path.join(BASE_UPLOADS, proveedor.carpeta, 'mapeo_imagenes.csv');

    let mapping = {};
    if (fs.existsSync(mappingCsv)) {
        await new Promise((resolve, reject) => {
            fs.createReadStream(mappingCsv)
                .pipe(csv())
                .on('data', (row) => {
                    if (row.Código && row.Nombre_Imagen) {
                        mapping[row.Código] = row.Nombre_Imagen;
                    }
                })
                .on('end', resolve)
                .on('error', reject);
        });
    }

    const records = [];
    try {
        await new Promise((resolve, reject) => {
            fs.createReadStream(filePath)
                .pipe(csv())
                .on('data', (row) => {
                    if (!Object.values(row).some(val => val && val.trim())) return;

                    let record = {
                        Código: row.Código ? row.Código.substring(0, 50).trim() : 'UNKNOWN_CODE_' + Math.random().toString(36).substring(2, 8),
                        Descripción: row.Descripción ? row.Descripción.substring(0, 255).trim() : 'Sin descripción',
                        Marca: row.Marca ? row.Marca.trim() : '',
                        Modelo: row.Modelo ? row.Modelo.trim() : '',
                        'Precio USD': row['Precio USD'] && !isNaN(parseFloat(row['Precio USD'])) ? parseFloat(row['Precio USD']).toFixed(2) : '0.00',
                        Referencia: row.Referencia && !isNaN(parseFloat(row.Referencia)) ? parseFloat(row.Referencia).toFixed(2) : (parseFloat(row['Precio USD']) * 1.43).toFixed(2),
                        Proveedor: proveedorId,
                        Imagen: mapping[row.Código] && fs.existsSync(path.join(imageDir, mapping[row.Código]))
                            ? `${imageBasePath}${mapping[row.Código]}`
                            : fs.existsSync(path.join(imageDir, `${row.Código.replace(/[\/\\ ]/g, '_')}.jpg`))
                            ? `${imageBasePath}${row.Código.replace(/[\/\\ ]/g, '_')}.jpg`
                            : DEFAULT_IMAGE
                    };
                    records.push(record);
                })
                .on('end', resolve)
                .on('error', reject);
        });
        res.json({ records });
    } catch (error) {
        logger.error(`Error al previsualizar CSV: ${error.message}`);
        res.status(500).json({ message: 'Error al previsualizar CSV' });
    }
});

// Aprobar CSV
app.post('/api/approve-csv', async (req, res) => {
    const { csvId } = req.body;
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) return res.status(401).json({ message: 'No autorizado' });

    try {
        const user = verifyToken(token);
        if (user.role !== 'admin') return res.status(403).json({ message: 'Solo administradores' });

        const { rows } = await pool.query('SELECT * FROM pending_csvs WHERE id = $1', [csvId]);
        if (!rows.length) return res.status(404).json({ message: 'CSV no encontrado' });

        const { file_path, proveedor_id } = rows[0];
        const proveedor = PROVEEDORES[proveedor_id];
        const destPath = path.join(BASE_UPLOADS, proveedor.carpeta, `${proveedor.nombre}.csv`);

        // Crear carpeta si no existe
        fs.mkdirSync(path.dirname(destPath), { recursive: true });
        fs.renameSync(file_path, destPath);
        await pool.query('UPDATE pending_csvs SET status = $1 WHERE id = $2', ['approved', csvId]);

        res.json({ message: 'CSV aprobado' });
    } catch (error) {
        logger.error(`Error al aprobar CSV: ${error.message}`);
        res.status(500).json({ message: 'Error al aprobar CSV' });
    }
});

// Rechazar CSV
app.post('/api/reject-csv', async (req, res) => {
    const { csvId } = req.body;
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) return res.status(401).json({ message: 'No autorizado' });

    try {
        const user = verifyToken(token);
        if (user.role !== 'admin') return res.status(403).json({ message: 'Solo administradores' });

        const { rows } = await pool.query('SELECT * FROM pending_csvs WHERE id = $1', [csvId]);
        if (!rows.length) return res.status(404).json({ message: 'CSV no encontrado' });

        fs.unlinkSync(rows[0].file_path);
        await pool.query('UPDATE pending_csvs SET status = $1 WHERE id = $2', ['rejected', csvId]);

        res.json({ message: 'CSV rechazado' });
    } catch (error) {
        logger.error(`Error al rechazar CSV: ${error.message}`);
        res.status(500).json({ message: 'Error al rechazar CSV' });
    }
});

// Rutas API
logger.info('Registrando rutas API');
app.use('/api/auth', require('./routes/auth').router);
app.use('/api/users', require('./routes/users'));
app.use('/api/products', require('./routes/products'));
app.use('/api/orders', require('./routes/orders')(io));
app.use('/api/sales', salesRouter);
app.use('/api/customer-orders', require('./routes/customerOrders'));
app.use('/api/proveedores', require('./routes/suppliers'));
app.use('/api/stats', require('./routes/stats'));
app.use('/api/newsletter', require('./routes/newsletter'));
app.use('/api/settings', require('./routes/settings'));
app.use('/api/proveedores', suppliersRoutes);
app.use('/Uploads', express.static(BASE_UPLOADS));
app.use('/img', express.static(BASE_UPLOADS));

// WebSocket con autenticación
io.use((socket, next) => {
    const token = socket.handshake.auth.token;
    logger.info(`Intentando autenticar WebSocket con token: ${token ? 'presente' : 'no proporcionado'}`);
    if (!token) {
        logger.error('No se proporcionó token para WebSocket');
        return next(new Error('Autenticación requerida'));
    }
    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        socket.user = decoded;
        logger.info(`Token válido para WebSocket, id: ${decoded.id}`);
        next();
    } catch (error) {
        logger.error(`Error verificando token WebSocket: ${error.message}`);
        return next(new Error('Token inválido'));
    }
});

io.on('connection', (socket) => {
    logger.info(`Cliente conectado: ${socket.id}, id: ${socket.user?.id || 'desconocido'}`);
    socket.on('productUpdated', (data) => {
        logger.info('Producto actualizado, notificando:', data);
        io.emit('productUpdated', data);
    });
    socket.on('newOrder', (data) => {
        logger.info('Nuevo pedido recibido:', data);
        io.emit('newOrder', data);
    });
    socket.on('disconnect', () => {
        logger.info(`Cliente desconectado: ${socket.id}, id: ${socket.user?.id || 'desconocido'}`);
    });
});

app.set('io', io);

// Manejo de rutas no encontradas
app.use((req, res) => {
    logger.warn(`Ruta no encontrada: ${req.originalUrl}`);
    res.status(404).json({ error: 'Ruta no encontrada' });
});

// Middleware para manejar errores no capturados
app.use((err, req, res, next) => {
    logger.error(`Error no manejado: ${err.message}, stack: ${err.stack}`);
    res.status(500).json({ error: 'Error interno del servidor', message: err.message });
});

// Iniciar servidor
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
    logger.info(`Servidor corriendo en http://localhost:${PORT}`);
});